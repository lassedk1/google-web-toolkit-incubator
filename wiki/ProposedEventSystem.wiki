= Introduction =

The current listener widget event system is very easy to use and understand, which are significant advantages. However, it has certain disadvantages as well, therefore in this document we:
  * Detail the disadvantages of the current listeners system.
  * Explain the proposed event handler system.
  * Revisit the disadvantages of the current listener system and show how the handler system addresses each one. 



= Disadvantages of current listener system =
  # We cannot add extra information about an event
    * Why: Because modifying an interface is a breaking change.
    * Example: We could not add native events to the current `Click` or `Change` listeners.
  # We cannot add a new feature to a current listener. 
    * Why: Because modifying an interface is still a breaking change.
    * Example: `TreeListener` cannot be expanded to allow more tree events.
  # Many widgets do not have any listeners, and yet have three or four listeners fields that need to be null initialized. 
    * Example: Most `Label` widgets have no events, yet have three fields that need to be null initialized.
  # We have to sink unnecessary events on widgets. 
    * Why: Because a widget cannot know what handler methods the user requires
    * Example: To listen to a mouse down event, mouse move events are also sunk. 
  # Our users end up with many empty event methods or need to extend from Adapter classes. 
    * Why: Users only usually care about a subset of  listener methods defined in the interface.
    * Example: to add a mouse up listener, you end up with empty mouse down and mouse move methods as well.
  # We repeat the same lines of boiler plate code in many different widgets to check if the listeners are instantiated and instantiate them. Therefore, no individual listener method can every be inlined away.
   * Example:
{{{
  if(clickListeners == null) {
    sinkEvents(Event.ON_CLICK);
    clickListeners = new ClickListenerCollection(); 
  }
  clickListeners.add(handler);
}}} 
  # All event senders must be widgets.
    * Why: because interface sender is defined as a `Widget`.
  # All widget creators must sink their own events.
  

= Proposed Handler System =
== Widget event API == 
This it the API that will be used by all GWT users.

=== Class overview ===
  * `AbstractEvent`
   * Base class for all events
   * New Event classes  
    * `ClickEvent`
    * `KeyDownEvent`
    * ...
  * `HandlerRegistration`
   *  Bookkeeping class to allow handlers to be removed from widgets.
  * `EventHandler`
   * Base interface for all handlers
   * New handler interfaces
    * `ClickHandler`
     * `onClick(ClickEvent event)`
    * `KeyDownHandler`
     * `onKeyDown(KeyDownEvent event)`
    * ...
  * For each handler, we also have a source with a single add method
   * `FiresClickEvents`
    * `HandlerRegistation addClickHandler(ClickEvent event)`
   * `FiresKeyDownEvents`
    * `HandlerRegistration addKeyDownHandler(KeyDownEvent event)`
   * ...
=== How it works ===
  * Each handler has a single method with a single argument, such as `onClick(ClickEvent event)` or `onKeyDown(KeyDownEvent event)`
  * Each widget supporting an event type has a method to add a handler of the form `HandlerRegistration addClickHandler(ClickHandler handler)`
  * To remove a handler, you must save the handler registration and call `registration.removeHandler()`

=== Sample use of a handler ==
{{{
 DateBox start = new DateBox();
 start.addKeyDownHandler(new KeyDownHandler() {
      public void onKeyDown(KeyDownEvent e) {
        if (e.getKeyCode() == KEY_RIGHT){
           ... 
        }
      }
    });
}}}

== Widget Developer Event API ==
This is the API that will be used by most widget creators who are creating and packaging their own widgets.

=== Class overview ===
  
  * `EventHook`
   * Event hook is used to allow the widget to hook a handler to a specific event.
   * For each event type, we have a specific hook, such as 
     * `ClickEvent.HOOK`
     * `KeyDownEvent.Hook`
     * ...
  * Widget enhancements
    * `final HandlerRegistration addEventHandler(EventHook hook, EventHandler handler)`
    * `final void fireEvent(AbstractEvent event)`


=== How it works ===
  * When a handler is added to a widget, the widget calls `addEventHandler` with the event's hook and the supplied handler.
{{{
 public void addKeyDownHandler(KeyDownHandler handler) {
    addEventHandler(KeyDownEvent.HOOK, handler);
 }
}}}
  * To use the widget's handlers, the widget must create an event object, then call `fireEvent` on that event object.
{{{
  @Override
  public void onBrowserEvent(Event e){
    ...
    case ON_KEYDOWN:
      fireEvent(new KeyDownEvent(e)); 
  }
}}}


=== Sample widget event handling code ==
{{{
public class DateBox extends Composite implements FiresKeyDownEvents {
...

 public void addKeyDownHandler(KeyDownHandler handler) {
    addEventHandler(KeyDownEvent.HOOK, handler);
 }
  @Override
  public void onBrowserEvent(Event e){
    ...
    case ON_KEYDOWN:
      fireEvent(new KeyDownEvent(e)); 
  }
}}}

== Advanced widget creation ==
=== Classes ===
  * `HandlerManager`
   * Manages all event handlers for widgets. `Widget` lazily creates a `HandlerManager` instance when `addEventHandler` is called.
   * Each `HandlerManager` is associated with a single widget. That widget is set as the source for all events passed into the handler.

=== Protected methods ===
 * `EventHook`
  *`void hookEvent(HandlerManager manager, EventHandler handler)`
   * setup method that is called when an event handler is added to a widget. Allows the handler system to take care of sinking events when appropriate.
 * `AbstractEvent`
  * `abstract void fire(EventHandler handler)`
   * allows events to specify correct handler method.
  * `abstract EventHook getEventHook()`
   * allows event instances to specify the correct static event hook to use.

=== Steps to create a custom event ===
  # Define a new event class
{{{
public class KeyDownEvent extends KeyEvent{
  ...
}
}}}
  # Define a new handler and fires class for the event class.
{{{
interface KeyDownHandler extends EventHandler {
  public void onKeyDown(KeyDownEvent event);
}

interface FiresKeyDownEvents {
  public void addKeyDownHandler(KeyDownHandler handler);
}
}}}
  # Wire up the `KeyDownEvent.fire` method
{{{
class KeyDownEvent extends KeyEvent {
  public void fire(EventHandler handler) {
    ((KeyDownHandler)handler).onKeyDown(this);
  }
  ...
}
}}}
  # Add a unique event hook
{{{
class KeyDownEvent extends KeyEvent {
  public static EventHook HOOK = new EventHook();
 
  public EventHook getEventHook(){
    return HOOK; 
  }
  ...
}
}}}
  # Wire up `EventHook.hookEvent` if necessary
{{{
public void hookEvent(EventManager eventManager, EventHandler handler) {
  // Sanity checks
  Object sender = eventManager.getEventSource();
  assert(handler instanceof KeyDownHandler);
  assert(sender instanceof FiresKeyDownEvents);

  if(eventManager.isFirstHandler(handler){
    // If source implements sink events, sink ON_KEYDOWN
    BrowserEvent.trySinkEvents(source, Event.ON_KEYDOWN);
  }
}
}}}

=== Sample event creation === 
{{{
public interface KeyDownHandler extends EventHandler {
  public void onKeyDown(KeyDownEvent event);
}

public interface FiresKeyDownEvents {
  public void addKeyDownHandler(KeyDownHandler handler);
}

public class KeyDownEvent extends KeyEvent {
  public static EventHook HOOK = new EventHook(){
    public void hookEvent(EventManager eventManager, EventHandler handler) {
      // Sanity checks
      Object sender = eventManager.getEventSource();
      assert(handler instanceof KeyDownHandler);
      assert(sender instanceof FiresKeyDownEvents);

      if(eventManager.isFirstHandler(handler){
        // If source implements sink events, sink ON_KEYDOWN
        BrowserEvent.trySinkEvents(source, Event.ON_KEYDOWN);
      }
     }
  };
  public EventHook getEventHook(){
    return HOOK; 
  }

  public void fire(EventHandler handler) {
    ((KeyDownHandler)handler).onKeyDown(this);
  }
   
}


}}}
== Class Diagram ==
  * Widget API classes are in blue
  * Widget developer classes are in green
  * Advanced widget developer classes are in black

http://google-web-toolkit-incubator.googlecode.com/svn/trunk/doc/wiki-support/images/HandlerDesign.jpg
 
== How it actually works ==
 * Adding event handler *myHandler* as a handler for `MyEvent`
   # In `Widget`
    * ensure `HandlerManager` *handlerManager* instance exists
    * call `handlerManager.addEventHandler(MyEvent.HOOK, myHandler)`
   # In `HandlerManager`  
    * store *myHandler* in a map indexed by event hook
    * call `EventHook.hookEvent` for event specific setup
 * Firing a `MyEvent` event
   # In 'Widget'
    * create new `MyEvent` *myEvent* instance
    * call `handlerManager.fireEvent(myEvent)`
   # In `HandlerManager`
    * set the correct sender field in *myEvent*
    * get the correct event hook from *myEvent*, in specific `MyEvent.HOOK`
    * retrieve the list of handlers associated with `MyEvent.HOOK`
    * call  `myEvent.fireEvent(handler)` on each handler in the list. 
   # In 'MyEvent'
    * cast the current handler as a`MyEventHandler`
    * call correct handler method on the current handler, passing in the current event.
 

 
== How the handler system solves problems ==

||Listener Problem || Handler solution ||
||(1) Cannot add extra information about an event. || Can add metadata to event ||
||(2) Cannot add extra features || Each handler represents a single method, so more can always be added || 
||(3) Excess unused listener fields || A single handlers field is used ||
||(4) Excess events are sunk || Only the events that are needed are sunk ||
||(5) Extra blank methods || No extra methods needed ||
||(6) Boiler plate code || Between `Widget` enhancements and `HandlerManager` classes, most boiler plate code removed ||
|| (7) All event senders must be widgets || Senders simply must implement the `Fires*` interface ||
|| (8) All widgets must manage sinking of events || All standard widgets have events sunk automatically ||