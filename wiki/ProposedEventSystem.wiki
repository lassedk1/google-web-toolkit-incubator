= Introduction =

The current listener widget event system is very easy to use and understand, which are significant advantages. However, it has certain disadvantages as well, therefore in this document we:
  * Detail the disadvantages of the current listeners system.
  * Explain the proposed event handler system.
  * Revisit the disadvantages of the current listener system and show how the handler system addresses each one. 



= Disadvantages of current listener system =
  # We cannot add extra information about an event
    * Why: Because modifying an interface is a breaking change.
    * Example: We could not add native events to the current `Click` or `Change` listeners.
  # We cannot add a new feature to a current listener. 
    * Why: Because modifying an interface is still a breaking change.
    * Example: `TreeListener` cannot be expanded to allow more tree events.
  # Many widgets do not have any listeners, and yet have three or four listeners fields that need to be null initialized. 
    * Example: Most `Label` widgets have no events, yet have three fields that need to be null initialized.
  # We have to sink unnecessary events on widgets. 
    * Why: Because a widget cannot know what handler methods the user requires
    * Example: To listen to a mouse down event, mouse move events are also sunk. 
  # Our users end up with many empty event methods or need to extend from Adapter classes. 
    * Why: Users only usually care about a subset of  listener methods defined in the interface.
    * Example: to add a mouse up listener, you end up with empty mouse down and mouse move methods as well.
  # We repeat the same lines of boiler plate code in many different widgets to check if the listeners are instantiated and instantiate them. 
   * Example:
{{{
    if(clickListeners == null) {
      sinkEvents(Event.ON_CLICK);
      clickListeners = new ClickListenerCollection(); 
    }
    clickListeners.add(handler);
}}} 
  # All event senders must be widgets.
    * Why: because interface sender is defined as a `Widget`.
  # All widget creators must sink their own events.
  

= Proposed Handler System =
== Widget event API == 
This it the API that will be used by all GWT users.

=== Class overview ===
  * `AbstractEvent`
   * Base class for all events
   * New Event classes  
    * `ClickEvent`
    * `KeyDownEvent`
    * ...
  * `HandlerRegistration`
   *  Bookkeeping class to allow handlers to be removed from widgets.
  * `EventHandler`
   * Base interface for all handlers
   * New handler interfaces
    * `ClickHandler`
     * `onClick(ClickEvent event)`
    * `KeyDownHandler`
     * `onKeyDown(KeyDownEvent event)`
    * ...
  * For each handler, we also have a source with a single add method
   * `FiresClickEvents`
    * `HandlerRegistation addClickHandler(ClickEvent event)`
   * `FiresKeyDownEvents`
    * `HandlerRegistration addKeyDownHandler(KeyDownEvent event)`
   * ...
=== How it works ===
  * Each handler has a single method with a single argument, such as `onClick(ClickEvent event)` or `onKeyDown(KeyDownEvent event)`
  * Each widget supporting an event type has a method to add a handler of the form `HandlerRegistration addClickHandler(ClickHandler handler)`
  * To remove a handler, you must save the handler registration and call `registration.removeHandler()`

=== Sample use of a handler ==
{{{
 DateBox start = new DateBox();
 start.addKeyDownHandler(new KeyDownHandler() {
      public void onKeyDown(KeyDownEvent e) {
        if (e.getKeyCode() == KEY_RIGHT){
           ... 
        }
      }
    });
}}}

== Widget Developer Event API ==
This is the API that will be used by most widget creators who are creating and packaging their own widgets.

=== Class overview ===
  
  * `EventHook`
   * Event hook is used to allow the widget to hook a handler to a specific event.
   * For each event type, we have a specific hook, such as 
     * `ClickEvent.HOOK`
     * `KeyDownEvent.Hook`
     * ...
  * Widget enhancements
    * `final HandlerRegistration addEventHandler(EventHook hook, EventHandler handler)`
    * `final void fireEvent(AbstractEvent event)`


=== How it works ===
  * When a handler is added to a widget, the widget calls `addEventHandler` with the event's hook and the supplied handler.

  * To use the widget's handlers, the widget must create an event object, then call `fireEvent` on that event object.


=== Sample widget event handling code ==
{{{
public class DateBox extends Composite implements FiresKeyDownEvents {
...

 public void addKeyDownHandler(KeyDownHandler handler) {
    addEventHandler(KeyDownEvent.HOOK, handler);
 }
  @Override
  public void onBrowserEvent(Event e){
    ...
    case ON_KEYDOWN:
      fireEvent(new KeyDownEvent(e)); 
  }
}}}

== Advanced widget creation ==
=== Classes ===
  * `HandlerManager`
   * Manages all event handlers for widgets. `Widget` lazily creates a `HandlerManager` instance when `addEventHandler` is called.
   * Each `HandlerManager` is associated with a single widget. That widget is set as the source for all events passed into the handler.

=== Protected methods ===
 * `EventHook`
  *`void hookEvent(HandlerManager manager, EventHandler handler)`
   * setup method that is called when an event handler is added to a widget. Allows the handler system to take care of sinking events when appropriate.
 * `AbstractEvent`
   `abstract void fireEvent(EventHandler handler)`
    * allows events to specify correct handler method.
   `abstract EventHook getEventHook()`
    * allows event instances to specify the correct static event hook to use.

=== Steps to create a custom event ===
  # Define a new event class
{{{
public class KeyDownEvent extends KeyEvent{
  ...
}
}}}
  # Define a new handler and fires class for the event class.
{{{
interface KeyDownHandler extends EventHandler {
  public void onKeyDown(KeyDownEvent event);
}

interface FiresKeyDownEvents {
  public void addKeyDownHandler(KeyDownHandler handler);
}
}}}
  # Wire up the `KeyDownEvent.fireEvent` method
{{{
class KeyDownEvent extends KeyEvent {
  public void firesEvent(EventHandler handler) {
    ((KeyDownHandler)handler).onKeyDown(this);
  }
  ...
}
}}}
  # Add a unique event hook
{{{
class KeyDownEvent extends KeyEvent {
  public static EventHook HOOK = new EventHook();
 
  public EventHook getEventHook(){
    return HOOK; 
  }
  ...
}
}}}
  # Wire up `EventHook.hookEvent` if necesary
{{{
class KeyDownEvent extends KeyEvent {
  public static EventHook HOOK = new EventHook(){
    public void hookEvent(EventManager eventManager, EventHandler handler) {
      // Sanity checks
      Object sender = eventManager.getEventSource();
      assert(handler instanceof KeyDownHandler);
      assert(sender instanceof FiresKeyDownEvents);

      if(eventManager.isFirstHandler(handler){
        // If source implements sink events, sink ON_KEYDOWN
        BrowserEvent.trySinkEvents(source, Event.ON_KEYDOWN);
      }
    }
    ...
  }
 }
}}}



== Class Diagram ==
Widget API classes are in blue

http://google-web-toolkit-incubator.googlecode.com/svn/trunk/doc/wiki-support/images/HandlerDesign.jpg
 
 
== How the handler system solves problems ==

||Listener Problem || Handler solution ||
||(1) Cannot add extra information about an event. || Can add metadata to event ||
||(2) Cannot add extra features || Each handler represents a single method, so more can always be added || 
||(3) Excess unused listener fields || A single handlers field is used ||
||(4) Excess events are sunk || Only the events that are needed are sunk ||
||(5) Extra blank methods || No extra methods needed ||
||(6) Boiler plate code || Between `Widget` enhancements and `HandlerManager` classes, most boiler plate code removed ||
|| (7) All event senders must be widgets || Senders simply must implement the `Fires*` interface ||
|| (8) All widgets must manage sinking of events || All standard widgets have events sunk automatically ||