#summary DRAFT Proposed event system for widgets

= Introduction =

The current listener widget event system is very easy to use and understand, which are significant advantages. However, it has certain disadvantages as well, therefore in this document we:
  * Detail the disadvantages of the current listeners system.
  * Explain the proposed handlers event system.
  * Revisit the disadvantages of the current listener system and show how the handler system addresses each one. 



= Disadvantages of current listener system =
  # We cannot add extra information about an event. 
    * For example, we could not add native events to the current `Click` or `Change` listeners.
  # We cannot add a new feature to a current listener. 
    * For example, `TreeListener` cannot be expanded to allow more tree events.
  # Many widgets do not have any listeners, and yet have three or four listeners fields that need to be null initialized. 
    * For example, most `Label` widgets have no events, yet have three fields that need to be null initialized.
  # We have to sink unnecessary events on widgets. 
    * For example to listen to a mouse down event, mouse move events are also sunk. 
  # Our users end up with many blank empty event methods or need to extend from Adapter classes. 
    * For example, to add a mouse up listener, you end up with empty mouse down and mouse move methods as well.
  # We repeat the same lines of boiler plate code in many different widgets to check if the listeners are instantiated and instantiate them. 
   * For example:
{{{
    if(clickListeners == null) {
      sinkEvents(Event.ON_CLICK);
      clickListeners = new ClickListenerCollection(); 
    }
    clickListeners.add(handler);
}}} 
  # All event senders must be widgets.
  # All widget creators must manage when to sink events, which is a very common source of bugs.
  

= Proposed Handler System =
== Overview ==
  * Each handler has a single method, such as `onClick`, `onMouseDown`, etc.
  * Each handler method has a single argument, which is exactly the handlerâ€™s corresponding event.  
  * `Widget` has the following new methods
    * `protected HandlerRegistration addEventHandler(EventHook hook, EventHandler handler)` 
    * `protected void fireEvent(AbstractEvent event)`
  * `Widget` delegates all event handling to a new lazily initialized `HandlerManager` instance.
  * `EventHandler` is removed by calling `removeHandler()` on the returned `HandlerRegistration`

== Class Diagram ==
http://google-web-toolkit-incubator.googlecode.com/svn/trunk/doc/wiki-support/images/HandlerDesign.jpg

== Sample code ==

=== Sample use of a handler ==
To use a handler, you must be able to use the classes in *blue* above.
{{{
 DateBox start = new DateBox();
 start.addKeyDownHandler(new KeyDownHandler() {
      public void onKeyDown(KeyDownEvent e) {
        if (e.getKeyCode() == KEY_RIGHT){
           ... 
        }
      }
    });
}}}


=== Sample widget implementation of a handler==
To implement a handler, you must be able to use the classes in *green* above.

{{{
public class DateBox extends Composite implements FiresKeyDownEvents {
...

 public void addKeyDownHandler(KeyDownHandler handler) {
    addEventHandler(KeyDownEvent.HOOK, handler);
 }
  @Override
  public void onBrowserEvent(Event e){
    ...
    case ON_KEYDOWN:
      fireEvent(new KeyDownEvent(e)); 
  }
  }}}

===  Sample declaration of a new handler interface ===
{{{
interface KeyDownHandler extends EventHandler {
  public void onKeyDown(KeyDownEvent event);
} 
}}}

=== Sample declaration of an event ===
{{{
class KeyDownEvent extends KeyEvent {
 public static Hook HOOK = new Hook(){
    public void hookEvent(HandlerRegistration registration) {
      // Sanity checks
      assert(registration.getHandler() instanceof KeyDownHandler);
      assert(registration.getSource() instanceof FiresKeyDownEvents);

      if(registration.isFirstHandlerForEvent()){
        // If source implements sink events, sink ON_KEYDOWN
        BrowserEvent.trySinkEvents(source, Event.ON_KEYDOWN);
      }
    }
  }

  public HandlerHook getEventHook() {
    return HOOK;
  }
  
  public void fire(EventHandler handler) {
    ((KeyDownHandler)handler).onKeyDown(this));
  }
}
}}}

== How the handler system solves problems ==

||Listener Problem || Handler solution ||
||(1) Cannot add extra information about an event. || Can add metadata to event ||
||(2) Cannot add extra features || Each handler represents a single method, so more can always be added || 
||(3) Excess unused listener fields || A single handlers field is used ||
||(4) Excess events are sunk || Only the events that are needed are sunk ||
||(5) Extra blank methods || No extra methods needed ||
||(6) Boiler plate code || Between `Widget` enhancements and `HandlerManager` classes, most boiler plate code removed ||
|| (7) All event senders must be widgets || Senders simply must implement the `Fires*` interface ||
|| (8) All widgets must manage sinking of events || All standard widgets have events sunk automatically ||