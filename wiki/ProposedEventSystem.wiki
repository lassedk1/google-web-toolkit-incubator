#labels Type-Library
= Introduction =

The current listener widget event system is very easy to use and understand, which are significant advantages. However, it has certain disadvantages as well, therefore in this document we:
  * Detail the disadvantages of the current listeners system.
  * Explain the proposed event handler system.
  * Revisit the disadvantages of the current listener system and show how the handler system addresses each one. 


= Disadvantages of current listener system =
  # We cannot add extra information about an event.
    * Why: Because modifying an interface is a breaking change.
    * Example: We could not add native events to the current `Click` or `Change` listeners.
  # We cannot add a new feature to a current listener. 
    * Why: Because modifying an interface is still a breaking change.
    * Example: `TreeListener` cannot be expanded to allow more tree events.
  # Many widgets do not have any listeners, and yet have three or four listeners fields that need to be null initialized. 
    * Example: Most `Label` widgets have no events, yet have three fields that need to be null initialized.
  # We have to sink unnecessary events on widgets. 
    * Why: Because many event listeners bundle several event methods in a single listener interface.
    * Example: To listen to a mouse down event, mouse move events are also sunk. 
  # Our users end up with many empty event methods or need to extend from Adapter classes. 
    * Why: Users only usually care about a subset of  listener methods defined in the interface.
    * Example: to add a mouse up listener, you end up with empty mouse down and mouse move methods as well.
  # We repeat the same lines of boiler plate code in many different widgets to check if the listeners are instantiated and instantiate them. Therefore, no individual listener method can ever be inlined away.
   * Example:
{{{
  if(clickListeners == null) {
    sinkEvents(Event.ON_CLICK);
    clickListeners = new ClickListenerCollection(); 
  }
  clickListeners.add(handler);
}}} 
  # All event sources must be widgets.
    * Why: because interface handler methods define the source as `Widget`.
  # All widget creators must sink their own events.
  

= Proposed Handler System =
== Widget event API == 
This is the API that will be used by all GWT users. It allows users to add new handlers to widgets.

=== Class overview ===
  * `AbstractEvent`
   * Base class for all events
   * New Event classes  
    * `ClickEvent`
      * Event which wraps a native click event.
    * `KeyDownEvent`
      * Event which wraps a native key down event.
    * ...
  * `HandlerRegistration`
   *  Bookkeeping class to allow handlers to be removed from widgets. Each time a handler is added to a widget, a `HandlerRegistration` instance is returned
  * `EventHandler`
   * Base interface for all handlers
   * New handler interfaces
    * `ClickHandler`
     * `onClick(ClickEvent event)`
    * `KeyDownHandler`
     * `onKeyDown(KeyDownEvent event)`
    * ...
  * For each event, we create an interface for adding event handlers..
   * `FiresClickEvents`
    * `HandlerRegistation addClickHandler(ClickHandler handler)`
       * Adds a click handler to the given widget.
   * `FiresKeyDownEvents`
    * `HandlerRegistration addKeyDownHandler(KeyDownHandler event)`
      * Adds a key down handler to the given widget.
   * ...
=== How it works ===
  * Each handler has a single method with a single argument, such as `void onClick(ClickEvent event)` or `void onKeyDown(KeyDownEvent event)`.
  * Each widget supporting an event type will implement the appropriate `Fires` interface and therefore have a method of the form `HandlerRegistration addFooHandler(FooEvent)`. For example a widget supporting a click handler must implement `FiresClickEvents`. 
  * To remove a handler, you must save the `HandlerRegistration` instance returned from the handler's add method and call `removeHandler()` on it.

=== Sample use of a handler ==
{{{
 DateBox start = new DateBox();
 start.addKeyDownHandler(new KeyDownHandler() {
      public void onKeyDown(KeyDownEvent e) {
        if (e.getKeyCode() == KEY_RIGHT){
           Window.alert("I have to be right");
        }
      }
    });
}}}

== Widget Developer Event API ==
This is the API that will be used by most widget creators who are creating and packaging their own widgets.  It allows widgets to hook up new handlers and send events to them.

=== Class overview ===
  
  * `AbstractEvent.Key`
   * The unique key used to represent a event type. It is primarily used to associate handers and events. 
   * For each event type, we have a specific key
     * `ClickEvent.KEY`
       * The key used to register handlers on a click event.
     * `KeyDownEvent.KEY`
       * The key used to register  handlers on a key down event.
     * ...
=== Protected methods ===
  * In `Widget` 
    * `protected final HandlerRegistration addEventHandler(AbstractEvent.Key key, EventHandler handler)`
      *  Registers the handler for the specific type represented by the event key.
    * `protected final void fireEvent(AbstractEvent event)`
      *  Fires the event to all registered handlers. 
    * `protected void  subscribeTo(AbstractEvent.Key eventKey)`
      *  Prepares the widget to fire the given event type.   The default implementation sinks native events where appropriate.

=== How it works ===
  * When a handler is added to a widget, the widget calls `addEventHandler` with the event's key and the supplied handler.
{{{
 public void addKeyDownHandler(KeyDownHandler handler) {
    addEventHandler(KeyDownEvent.KEY, handler);
 }
}}}
  *  If this is the first time a handler of a given type has been added a widget, the widget's `subscribeTo` method is called. 
{{{
  public void subscribeTo(AbstractEvent.Key key) {
     if(key instanceof BrowserEvent.Key) {
       int eventToSink = ((BrowserEvent.Key)key).getEventToSink();
       sinkEvents(eventToSink);
     }
  } 

}}} 
  * To use the widget's handlers, the widget must create an event object, then call `Widget`'s `fireEvent`.  
{{{
  @Override
  public void onBrowserEvent(Event e){
    ...
    case ON_KEYDOWN:
      fireEvent(new KeyDownEvent(e)); 
  }
}}}


=== Sample widget event handling code ===
This code shows how to wire a `DateBox` to handle a `KeyDownHandler`. In  other words, this sample implements the `DataBox.addKeyDownEvent`  functionality used above.

{{{
public class DateBox extends Composite implements FiresKeyDownEvents {
...

 // implements FiresKeyDownEvents.addKeyDownHandler
 public void addKeyDownHandler(KeyDownHandler handler) {
    // Widget's addEventHandler method. Registers the current handler as a KeyDownEvent handler.
    addEventHandler(KeyDownEvent.KEY, handler);
 }
  @Override
  public void onBrowserEvent(Event e){
    ...
    case ON_KEYDOWN:
      // Widget's fireEvent method. It will call each handler registered to KeyDownEvent.
      fireEvent(new KeyDownEvent(e)); 
  }
}
}}}

== Advanced widget creation ==
This API is for those widget creators who need to create custom events and for those creating widgets that do not extend `Widget`

=== Class Overview ===
  * `HandlerManager`
   * Manages all event handlers for widgets. `Widget` lazily creates a `HandlerManager` instance when `addEventHandler` is called.
   * Each `HandlerManager` is associated with a single widget. That widget is set as the source for all events passed into the manager. The associated 'widget' must implement a  characteristic interface. The exact name of the interface is To be determined.

=== Protected methods ===
 * `AbstractEvent`
  * `protected abstract void fire(EventHandler handler)`
   * Allows event instance to call correct handler method. For example 
{{{
public class KeyDownEvent extends KeyEvent<KeyDownHandler> {
  public void fire(KeyDownHandler handler) {
     handler.onKeyDown(this);
  }
 ...
}
}}}
  * `abstract AbstractEvent.Key getKey()`
   * Allows event instances to specify the static event key.  The event key can also contain additional useful information about the event type. For example
{{{
public class KeyDownEvent extends BrowserEvent {
  
  // BrowserEvent.Key overrides Key and adds a getEventToSink() attribute.  
  public static final BrowserEvent.Key KEY = new BrowserEvent.Key(Event.ON_KEY_DOWN);
 
   // This method allows the event, once created, to identify its key. The handler manager uses that information to dispatch the event to the correct handlers.
   public AbstractEvent.Key getKey(){
    return KEY;
  }
}
}}}


=== Steps to create a custom event ===
This is an event that is triggered when the user becomes happy. 

  # Define a new event class.  You can add arbitrary metadata in the event class. For simplicity, we will not include any here though.
{{{
public class HappyEvent extends AbstractEvent{
   ...
}
}}}
  # Define a new handler and fires class for the event class.
{{{
interface HappyHandler extends EventHandler {
  public void onHappiness(HappyEvent event);
}

interface FiresHappyEvents {
  public HandlerRegistration addHappyHandler(HappyHandler handler);
}
}}}
  # Wire up the `HappyEvent.fire` method
{{{
class HappyEvent extends AbstractEvent <HappyHandler> {
  protected void fire(HappyHandler handler) {
     happyHandler.onHappiness(this);
  }
  ...
}
}}}
  # Add a unique event key
{{{
class HappyEvent extends AbstractEvent <HappyHandler>{
  public static AbstractEvent.Key KEY = new AbstractEvent.Key();
 
  public AbstractEvent.Key getKey(){
    return KEY; 
  }
  ...
}
}}}
 
=== Full code needed to create a `Happy` handler === 

{{{
public interface HappyHandler extends EventHandler {
  public void onHappiness(HappyEvent event);
}

public interface FiresHappyEvents {
  public HandlerRegistration addHappyHandler(HappyHandler handler);
}

public class HappyEvent extends AbstractEvent <HappyHandler> {
  public static AbstractEvent.Key KEY = new AbstractEvent.Key( );

  public AbstractEvent.Key getKey(){
    return KEY; 
  }

  public void fire(HappyHandler handler) {
    handler.onHappiness(this);
  }
   
}

}}}
== Class Diagram ==
  * Widget API classes are in blue
  * Widget developer classes are in green
  * Advanced widget developer classes are in black

http://google-web-toolkit-incubator.googlecode.com/svn/trunk/doc/wiki-support/images/HandlerDesign.jpg
 
== How it actually works ==
 * Adding event handler *myHandler* as a handler for `MyEvent`
   # In `Widget`
    * ensure `HandlerManager` *handlerManager* instance exists
    * call `handlerManager.addEventHandler(MyEvent.KEY, myHandler)`
   # In `HandlerManager`  
    * store *myHandler* in a map indexed by event key
    * if this is the first handler of the given type, call `source.subscribeToEvent(myEvent.KEY)' for event specific setup
 * Firing a `MyEvent` event
   # In 'Widget'
    * create new `MyEvent` *myEvent* instance
    * call `handlerManager.fireEvent(myEvent)`
   # In `HandlerManager`
    * set the correct source field in *myEvent*
    * get the correct event key from *myEvent*, in specific `MyEvent.KEY`
    * retrieve the list of handlers associated with `MyEvent.KEY`
    * call  `myEvent.fireEvent(handler)` on each handler in the list. 
   # In `MyEvent`
    * cast the current handler as a `MyEventHandler`
    * call correct handler method on the current handler, passing in the current event.
 

 
== How the handler system solves problems ==

||Listener Problem || Handler solution ||
||(1) Cannot add extra information about an event || Can add metadata to event ||
||(2) Cannot add extra features || Each handler represents a single method, so more can always be added || 
||(3) Excess unused listener fields || A single manager field is used ||
||(4) Excess events are sunk || Only the events that are needed are sunk ||
||(5) Extra blank methods || No extra methods needed ||
||(6) Boiler plate code || Between `Widget` enhancements and `HandlerManager` classes, most boiler plate code removed. Remaining boiler plate code will be inlined ||
|| (7) All event sources must be widgets || sources simply must implement the `Fires*` interface ||
|| (8) All widgets must manage sinking of events || All standard widgets have events sunk automatically ||