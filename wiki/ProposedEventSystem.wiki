#summary DRAFT Proposed event system for widgets

= Introduction =

The current listener widget event system is very easy to use and understand, which are significant advantages. However, it has a reasonable number of disadvantages as well, therefore in this document we:
  * Detail the disadvantages of the current listeners system.
  * Explain the proposed handlers event system.
  * Revisit the disadvantages of the current listener system and show how the handler system addresses each one. 



= Disadvantages of current listener system =
  # We cannot add extra information about an event. 
    * For example, we could not add native events to the current `Click` or `Change` listeners.
  # We cannot add a new feature to a current listener. 
    * For example, `TreeListener` cannot be expanded to allow more tree events.
  # Many widgets do not have any listeners, and yet have three or four listeners fields that need to be null initialized. 
    * For example, most `Label` widgets have no events, yet have three fields that need to be null initialized.
  # We have to sink unnecessary events on widgets. 
    * For example to listen to a mouse down event, mouse move events are also sunk. 
  # Our users end up with many blank empty event methods or need to extend from Adapter classes. 
    * For example, to add a mouse up listener, you end up with empty mouse down and mouse move methods as well.
  # We repeat the same lines of boiler plate code in many different widgets to check if the listeners are instantiated and instantiate them. 
   * For example:
{{{
    if(clickListeners == null) {
      clickListeners = new ClickListenerCollection(); 
    }
    clickListeners.add(handler);
}}} 
  # All event senders must be widgets.

= Proposed Handler System =
== Overview ==
  * Each handler has a single method, such as `onClick`, `onMouseDown`, etc.
  * Each handler has a single argument, which is exactly the handlerâ€™s corresponding event.  
  * Widget has the following methods
    * `protected addEventHandler(Class eventType, EventHandler handler)` 
    * `protected removeEventHandler(Class eventType, EventHandler handler)`
  * Widget delegates all event handling to a new lazily initialized EventHandlers instance.

== Class Diagram ==
http://google-web-toolkit-incubator.googlecode.com/svn/trunk/doc/wiki-support/images/HandlerDesign.jpg

== Sample code ==
=== Sample widget implementation of a handler==

{{{
public class DateBox extends Composite implements FiresKeyDownEvents {
...

 public void addKeyDownHandler(KeyDownHandler handler) {
    addEventHandler(KeyDownEvent.class, handler);
  }

}}}

=== Sample use of a a handler ==
{{{

 start.addKeyDownHandler(new KeyDownHandler() {
      public void onKeyDown(KeyDownEvent e) {
        if (e.getKeyCode() == KEY_RIGHT){
        ... 
        }
      }
    });

}}}


== How the handler system solves problems ==

||Listener Problem || Handler solution ||
||(1) Cannot add extra information about an event. || Can add metadata to event ||
||(2) Cannot add extra features || Each handler represents a single method, so more can always be added || 
||(3) Excess unused listener fields || A single handlers field is used ||
||(4) Excess events are sunk || Only the events that are needed are sunk ||
||(5) Extra blank methods || No extra methods needed ||
||(6) Boiler plate code || Between `Widget` enhancements and `EventHandlers` classes, most boiler plate code removed ||
|| (7) All event senders must be widgets || Senders must implement the `Fires*` interface ||