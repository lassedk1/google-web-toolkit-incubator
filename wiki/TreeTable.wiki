#summary TreeTable

|| Live demo || [http://google-web-toolkit-incubator.googlecode.com/svn/branches/dflorey/tableAddons/demo/TreeTableDemo/TreeTableDemo.html] ||
|| Java docs || coming soon... ||
|| Sample code || [http://google-web-toolkit-incubator.googlecode.com/svn/branches/dflorey/tableAddons/src-demo/com/google/gwt/gen2/demo/scrolltable/client/TreeTableDemo.java Demo code] ||
|| Source starting point|| [http://google-web-toolkit-incubator.googlecode.com/svn/branches/dflorey/tableAddons/src/com/google/gwt/gen2/table/client/TreeTable.java TreeTable.java] ||

= Introduction =
The TreeTable is extending the gwt incubator table framework. The code currently exists in my branch. To check out the latest sources, type

{{{
svn checkout http://google-web-toolkit-incubator.googlecode.com/svn/branches/dflorey/tableAddons gwt-incubator-tableaddons
}}}

A TreeTable is able to show a tree where each tree item can have some additional fields that shall be displayed. 

= Details =

= Tutorial =

The following short tutorials will guide you to create a working !TreeTable.
The !TreeTable can be used to display data constructed on client side (in the browser) or to display large trees coming from the server.

== Client side table ==
This example will show you how to create a fully functional TreeTable on the client side without client / server communication.

=== Create the domain class ===

First of all we have to create a class reflecting the objects in our tree.
Let's create a fictional family tree, so we need a class representing our ancestors:

{{{
class Ancestor extends AbstractTreeTableItem {
    private String firstName, lastName;
    private double iq;
    private Date dateOfBirth;

    public Ancestor(String firstName, String lastName, int iq, Date dateOfBirth) {
      this.firstName = firstName;
      this.lastName = lastName;
      this.iq = iq;
      this.dateOfBirth = dateOfBirth;
    }

    public String getFirstName() {
      return firstName;
    }

    public String getLastName() {
      return lastName;
    }

    public double getIq() {
      return iq;
    }

    public Date getDateOfBirth() {
      return dateOfBirth;
    }

    @Override
    public String getDisplayName() {
      return firstName+" "+lastName;
    }

    @Override
    public String getId() {
      return firstName+lastName+dateOfBirth;
    }
}

}}}

Note that this class extends the AbstractTreeTableItem and we have to implement two abstract methods providing some info that the !TreeTable requires to work properly.
We have to implement the getDisplayName() method that should return a user friendly textual representation and the getId() method that has to return a unique id.

If you have an existing class that you want to display in a TreeTable you can also implement the TreeTableItem interface directly of you can simply wrap your class into the TreeTableItemWrapper.

=== Creating some sample data ===

{{{
private static String[] firstNames = {"Miguel", "Fred", "Bob", "Emily", "John", "Ray", "Bruce", "Ray", "Larry", "Sergey", "Bill", "Steve", "Daniel" };
private static String[] lastNames = {"Mendez", "Sauer", "Vatwer", "Crutcher", "LaBanca", "Ryan", "Johnson", "Cromwell", "Page", "Bin", "Gates", "Jobs", "Florey" };

List<TreeItem<Ancestor>> files = new ArrayList<TreeItem<Ancestor>>();
for (int i = 0; i < 12; i++) {
  TreeItem<Ancestor> ancestor = createAncestor();
  addChildren(ancestor, Random.nextInt(3) + 1, 0);
  files.add(ancestor);
}

private void addChildren(TreeItem<Ancestor> parent, int numberOfChildren, int level) {
  for (int i = 0; i < numberOfChildren; i++) {
    TreeItem<Ancestor> child = createAncestor();
    parent.addChild(child);
    if (level < 4) {
      addChildren(child, Random.nextInt(4) + 1, level + 1);
    }
  }
}

private TreeItem<Ancestor> createAncestor() {
  return new TreeItem(new Ancestor(firstNames[Random.nextInt(firstNames.length-1)], lastNames[Random.nextInt(lastNames.length-1)], Random.nextInt(50)+80, new Date((long)Random.nextInt(1000000)*500000L)));
}
}}}

There is no magic in this part of the code. Create a types TreeItem containing your domain object for each tree item and add children to each tree node as desired.

=== Define the table ===

You have to create a TableDefinition in order to tell the TreeTable which columns you want to display and what type of values they will contain.
The easiest way is to use the DefaultTableDefinition class:

{{{
DefaultTableDefinition<Ancestor> tableDefinition = new DefaultTableDefinition<Ancestor>();
tableDefinition.addColumnDefinition(new TextColumnDefinition<Ancestor>(
    "First name", true, false) {
  public String getCellValue(Ancestor ancestor) {
    return ancestor.getFirstName();
  }
});
tableDefinition.addColumnDefinition(new TextColumnDefinition<Ancestor>(
    "Last name", true, false) {
  public String getCellValue(Ancestor ancestor) {
    return ancestor.getLastName();
  }
});
tableDefinition.addColumnDefinition(new NumberColumnDefinition<Ancestor>(
    "IQ", NumberFormat.getDecimalFormat(), true, false) {
  public Double getCellValue(Ancestor ancestor) {
    return ancestor.getIq();
  }
});
tableDefinition.addColumnDefinition(new DateColumnDefinition<Ancestor>(
    "Date of birth", DateTimeFormat.getMediumDateFormat(), true, true,
    false) {
  public Date getCellValue(Ancestor ancestor) {
    return ancestor.getDateOfBirth();
  }
});
}}}

You have to provide a column definition for each column. The column definition will tell the table if this column shall be sortable, filterable, editable and which header to display.
There are already some column definition classes available for the most frequently used types. 
If you define a column you will be asked to implement the proper getter method to enable the table to access the right field belonging to the column.
If you define your column as editable you also have to implement the proper setter method.

=== Create the TreeTable ===

Now we are ready to create the TreeTable:

{{{
TreeTable<Ancestor> treeTable = new TreeTable<Ancestor>(tableDefinition,
    files, true);
treeTable.setPageSize(12);
treeTable.setResizePolicy(ScrollTable.ResizePolicy.FILL_WIDTH);
}}}

In our example we specify that the tree should be expanded by default by passing the optional boolean parameter set to true.

=== Create the TreeTableController

As we set our page size we get a paging tree table. To provide the tree table controls for paging and other features to the user we have to create a TreeTableController.

{{{
TreeTableController treeTableController = new TreeTableController(treeTable);
}}}

=== Putting it all together ===

Finally we will wrap both elements into a DockPanel, but this is nothing TreeTable specific, just daily business:

{{{
treeTableController.setWidth("100%");
treeTable.setSize("100%", "100%");
DockPanel dockPanel = new DockPanel();
dockPanel.setWidth("100%");
dockPanel.setHeight("300px");
dockPanel.add(treeTable, DockPanel.CENTER);
dockPanel.setCellHeight(treeTable, "100%");
dockPanel.setCellWidth(treeTable, "100%");
dockPanel.add(treeTableController, DockPanel.SOUTH);
}}}

That's it. You'll find a link to the full demo source code and the working output at the top of this page.